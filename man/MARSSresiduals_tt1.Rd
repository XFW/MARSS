\name{MARSSresiduals.tt1}
\alias{MARSSresiduals.tt1}

\title{ MARSS One-Step-Ahead Residuals }
\description{
  Calculates the standardized (or auxiliary) one-step-ahead residuals, aka the innovations residuals and their variance.  Not exported. Access this function with \code{MARSSresiduals(object, type="tt1")}. To get the residuals as a data frame in long-form, use \code{\link[=residuals.marssMLE{residuals}(object, type="tt1")}.
}
\usage{
MARSSresiduals.tt1(object, method=c("SS"), normalize=FALSE, silent=FALSE)
}
\arguments{
  \item{object}{ An object of class \code{\link{marssMLE}}.}
  \item{method}{ Algorithm to use. Currently only "SS". }
  \item{normalize}{ TRUE/FALSE See details. }
  \item{silent}{ If TRUE, don't print inversion warnings. }
}
\value{
A list with the following components  
  \item{model.residuals}{ The the observed one-step-ahead model residuals: data minus the model predictions conditioned on the data 1 to t-1. These are termed innovations. A n x T matrix. NAs will appear where the data are missing. }
  \item{state.residuals}{ The one-step-ahead state residuals \eqn{\tilde{\mathbf{x}}_{t}^{t} - \mathbf{Z}\tilde{\mathbf{x}}_{t-1}^{t-1} - \mathbf{u}}{E(X_{t}|y(1:t-1))-Z E(X_{t-1}|E(x_t-1|y(1:t-1)))}. Note, state residual at time \eqn{t} is the transition from time \eqn{t-1} to \eqn{t}. This is different than that returned for \code{\link{MARSSresiduals.tT}} where the state residual at time \eqn{t} is the transition from \eqn{t} to \eqn{t+1}. }
  \item{residuals}{ The residuals conditioned on the observed data up to time \eqn{t-1}. Returned as a (n+m) x T matrix with \code{model.residuals} in rows 1 to n and \code{state.residuals} in rows n+1 to n+m.  NAs will appear in rows 1 to n in the places where data are missing. }
  \item{var.residuals}{ The joint variance of the one-step-ahead residuals conditioned on observed data from 1 to t-1. Returned as a n+m x n+m x T matrix. }
  \item{std.residuals}{ The Cholesky standardized residuals as a n+m x T matrix. This is \code{residuals} multiplied by the inverse of the lower triangle of the Cholesky decomposition of \code{var.residuals}. The model standardized residuals associated with the missing data are replaced with NA. }
  \item{mar.residuals}{ The marginal standardized residuals as a n+m x T matrix. This is \code{residuals} multiplied by the inverse of the diagonal matrix formed by the square-root of the diagonal of \code{var.residuals}.  The model marginal residuals associated with the missing data are replaced with NA. }
    \item{E.obs.residuals}{ The expected value of the model residuals conditioned on the observed data 1 to t-1. Returned as a n x T matrix. Because all the data at time t are unobserved for the purpose of estimation (since conditioning is from 1 to t-1), this will be all 0s (unlike the case where we condition on the data from 1 to T or 1 to t). This and \code{var.obs.residuals} are included for completeness since they are returned for \code{\link{MARSSresiduals.tT}}, but they are not relevant for one-step-ahead residuals. See the discussion there. }
    \item{var.obs.residuals}{ For one-step-ahead residuals, this will be the same as the 1:n, 1:n upper diagonal block in \code{var.residuals} since none of the \eqn{t} data affect the residuals at time \eqn{t}, since the residuals are conditioned only on the data up to \eqn{t-1}. This is different for residuals conditioned on the data from 1 to T. This and \code{E.obs.residuals} are included for completeness since they are returned for \code{\link{MARSSresiduals.tT}}, but they are not relevant for one-step-ahead residuals. See the discussion there. Note, also included as a code check. They are computed differently, but \code{var.obs.residuals} and \code{var.residuals} should always be the same.}
  \item{msg}{ Any warning messages. This will be printed unless Object$control$trace = -1 (suppress all error messages). }

}
\details{

This function returns the conditional expected value (mean) and variance of the one-step-ahead residuals.  'conditional' means in this context, conditioned on the observed data up to time \eqn{t-1} and a set of parameters.  

\strong{Model residuals}

\eqn{\mathbf{v}_t}{v_t} is the difference between the data and the predicted data at time \eqn{t} given \eqn{\mathbf{x}_t}{x_t}:
\deqn{ \mathbf{v}_t = \mathbf{y}_t - \mathbf{Z} \mathbf{x}_t - \mathbf{a} }{ v_t = y_t - Z x_t - a}
The observed model residuals \eqn{\hat{\mathbf{v}}_t}{hatv_t} are the difference between the observed data and the predicted data at time \eqn{t} using the fitted model. \code{MARSSresiduals.tt1} fits the model using the data up to time \eqn{t-1}. So
\deqn{ \hat{\mathbf{v}}_t = \mathbf{y}_t - \mathbf{Z}\tilde{\mathbf{x}}_t^{t-1} - \mathbf{a} }{ hatv_t = y_t - Z xtt1 - a}
where \eqn{\tilde{\mathbf{x}}_t^{t-1}}{xtt1} is the expected value of \eqn{\mathbf{X}_t}{X_t} conditioned on the data from 1 to \eqn{t-1} from the Kalman filter. \eqn{\mathbf{y}_t}{y_t} are your data and missing values will appear as NA. 

\strong{State residuals}

\eqn{\mathbf{w}_t}{w_t} are the difference between the state at time \eqn{t} and the expected value of the state at time \eqn{t} given the state at time \eqn{t-1}:
\deqn{ \mathbf{w}_t = \mathbf{x}_t - \mathbf{B} \mathbf{x}_{t-1} - \mathbf{u} }{ w_t = x_t - B x_{t-1} - u}
The estimated state residuals \eqn{\hat{\mathbf{w}}_t}{hatw_t} are the difference between estimate of \eqn{\mathbf{x}_t}{x_t} minus the estimate using \eqn{\mathbf{x}_{t-1}}{x_{t-1}}. 
\deqn{ \hat{\mathbf{w}}_t = \tilde{\mathbf{x}}_t^{t-1} - \mathbf{B}\tilde{\mathbf{x}}_{t-1}^{t-1} - \mathbf{u} }{ hatw_t = xtt1 - B xt1t1 - u}
where \eqn{\tilde{\mathbf{x}}_t^{t-1}}{xtt1} is the Kalman filter estimate of the states at time \eqn{t} conditioned on the data up to time \eqn{t-1} and \eqn{\tilde{\mathbf{x}}_{t-1}^{t-1}}{xt1t1} is the Kalman filter estimate of the states at time \eqn{t-1} conditioned on the data up to time \eqn{t-1} (\code{xtt[,t-1]} returned by \code{\link{MARSSkf}}).
The estimated state residuals are returned in \code{state.residuals} and rows \eqn{n+1} to \eqn{n+m} of \code{residuals}. There are no NAs in the estimated state residuals as an estimate of the state exists whether or not there are associated data.

\code{res1} and \code{res2} in the code below will be the same.
\preformatted{dat = t(harborSeal)[2:3,]
TT = ncol(dat)
fit = MARSS(dat)
B = coef(fit, type="matrix")$B
U = coef(fit, type="matrix")$U
xtt1 <- MARSSkfss(fit)$xtt1[,1:(TT-1)] # t 1 to TT-1
xtt <- MARSSkfss(fit)$xtt[,2:TT] # t 2 to TT
res1 = xtt1 - B \%*\% xtt - U \%*\% matrix(1,1,TT-1)
res2 = MARSSresiduals(fit, type="tt1")$state.residuals
}

\strong{Joint residual variance}

In a state-space model, \eqn{\mathbf{X}}{X} and \eqn{\mathbf{Y}}{Y} are stochastic, and the model and state residuals are random variables \eqn{\hat{\mathbf{V}}_t}{hatV_t} and \eqn{\hat{\mathbf{W}}_{t}}{hatW_{t}}. To evaluate the residuals we observed (with \eqn{\mathbf{y}^{(1, t-1)}}{y(1, t-1)}), we use the joint distribution of \eqn{\hat{\mathbf{V}}_t, \hat{\mathbf{W}}_{t}}{hatV_t, hatW_{t}} across all the different possible data sets that our MARSS equations with parameters \eqn{\Theta}{Theta} might generate. Denote the matrix of \eqn{\hat{\mathbf{V}}_t, \hat{\mathbf{W}}_{t}}{hatV_t, hatW_{t}}, as as \eqn{\widehat{\mathcal{E}}_t}{Epsilon_t}. That distribution has an expected value (mean) and variance:
\deqn{ \textrm{E}[\widehat{\mathcal{E}}_t] = 0; \textrm{var}[\widehat{\mathcal{E}}_t] = \hat{\Sigma}_t }{ E[Epsilon_t] = 0; var[Epsilon_t] = hatSigma_t}
Our observed residuals \code{residuals} are one sample from this distribution.
To standardize the observed residuals, we will use \eqn{ \hat{\Sigma}_t }{ hatSigma_t }. \eqn{ \hat{\Sigma}_t }{ hatSigma_t } is returned in \code{var.residuals}. Rows/columns 1 to \eqn{n} are the conditional variances of the model residuals and rows/columns \eqn{n+1} to \eqn{n+m} are the conditional variances of the state residuals. The off-diagonal blocks are the covariances between the two types of residuals. For one-step-ahead residuals (unlike smoothation residuals \link{MARSSresiduals.tT}), the covariance is zero.

\code{var.residuals} returned by this function is the conditional variance of the residuals conditioned on the data up to \eqn{t-1} and the parameter set \eqn{\Theta}.  The conditional variance for the model residuals is 
\deqn{ \hat{\Sigma}_t = \mathbf{R}+\mathbf{Z}_t \mathbf{V}_t^{t-1} \mathbf{Z}_t^\top }{hatSigma_t = R + Z_t Vtt1 t(Z_t)}
where \eqn{\mathbf{V}_t^{t-1}}{Vtt1} is the variance of \eqn{\mathbf{X}_t}{X_t} conditioned on the data up to time \eqn{t-1}. This is returned by \code{\link{MARSSkf}} in \code{Vtt1}. The innovations variance is also returned in \code{Sigma} from \code{\link{MARSSkf}} and are used in the innovations form of the likelihood calculation.

\strong{Standardized residuals}

\code{std.residuals} are Cholesky standardized residuals. These are the residuals multiplied by the inverse of the lower triangle of the Cholesky decomposition of the variance matrix of the residuals: 
\deqn{ \hat{\Sigma}_t^{-1/2} \hat{\mathbf{v}}_t}{ hatSigma_t^{-1/2} hatv_t. }
These residuals are uncorrelated unlike marginal residuals. 

The interpretation of the Cholesky standardized residuals is not straight-forward when the \eqn{\mathbf{Q}}{Q} and \eqn{\mathbf{R}}{R} variance-covariance matrices are non-diagonal.  The residuals which were generated by a non-diagonal variance-covariance matrices are transformed into orthogonal residuals in MVN(0,I) space.  For example, if v is 2x2 correlated errors with variance-covariance matrix R. The transformed residuals (from this function) for the i-th row of v is a combination of the row 1 effect and the row 1 effect plus the row 2 effect.  So in this case, row 2 of the transformed residuals would not be regarded as solely the row 2 residual but rather how different row 2 is from row 1, relative to expected.  If the errors are highly correlated, then the Cholesky standardized residuals can look rather non-intuitive.

\code{mar.residuals} are the marginal standardized residuals. These are the residuals multiplied by the inverse of the diagonal matrix formed from the square-root of the diagonal of the variance matrix of the residuals: 
\deqn{ \textrm{dg}(\hat{\Sigma}_t)^{-1/2} \hat{v}_t}{ dg(hatSigma_t)^{-1/2} hatv_t}, where 'dg(A)' is the square matrix formed from the diagonal of A, aka \code{diag(diag(A))}. These residuals will be correlated if the variance matrix is non-diagonal. 

\strong{Normalized residuals}

If \code{normalize=FALSE}, the unconditional variance of \eqn{W_t} and \eqn{V_t} are \eqn{\mathbf{Q}}{Q} and \eqn{\mathbf{R}}{R} and the model is assumed to be written as
\deqn{ y_t = Z x_t + a + v_t}
\deqn{ x_t = B x_{t-1} + u + w_t}
If normalize=TRUE, the model is assumed to be written
\deqn{ y_t = Z x_t + a + Hv_t}
\deqn{ x_t = B x_{t-1} + u + Gw_t}
with the variance of \eqn{V_t} and \eqn{W_t} equal to I (identity).

\code{MARSSresiduals} returns the residuals defined as in the first equations. To get the residuals defined as Harvey et al. (1998) define them (second equations), then use \code{normalize=TRUE}.  In that case the unconditional variance of residuals will be I instead of \eqn{\mathbf{Q}}{Q} and \eqn{\mathbf{R}}{R}.  Note, that the `normalized' residuals are not the same as the `standardized' residuals.  In former, the unconditional residuals have a variance of I while in the latter it is the conditional residuals that have a variance of I.

}

\author{ 
  Eli Holmes, NOAA, Seattle, USA.  

  eli(dot)holmes(at)noaa(dot)gov
} 
\seealso{ \code{\link{MARSSresiduals.tT}}, \code{\link{MARSSresiduals.tt}},  \code{\link{fitted.marssMLE}}, \code{\link{plot.marssMLE}} }
\examples{
  dat <- t(harborSeal)
  dat <- dat[c(2,11),]
  fit <- MARSS(dat)
  
  MARSSresiduals(fit, type="tt1")$std.residuals
  residuals(fit, type="tt1")
}
\references{
R. H. Shumway and D. S. Stoffer (2006).  Section on the calculation of the likelihood of state-space models in Time series analysis and its applications.  Springer-Verlag, New York.

Holmes, E. E. 2014. Computation of standardized residuals for (MARSS) models. Technical Report. arXiv:1411.0045. 
}

