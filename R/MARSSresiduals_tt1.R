MARSSresiduals.tt1 <- function(object, method=c("SS"), normalize = FALSE, silent=FALSE) {
  # These are the residuals and their variance conditioned on the data up to time t-1
  MLEobj <- object
  method <- match.arg(method)
  model.dims <- attr(MLEobj$marss, "model.dims")
  TT <- model.dims[["x"]][2]
  m <- model.dims[["x"]][1]
  n <- model.dims[["y"]][1]
  y <- MLEobj$marss$data
  # set up holders
  et <- st.et <- mar.st.et <- matrix(NA, n+m, TT)
  model.et <- matrix(NA, n, TT)
  state.et <- state.st.et <- state.mar.st.et <- matrix(NA, m , TT)
  model.var.et <- array(0, dim = c(n, n, TT))
  var.et <- array(0, dim = c(n+m, n+m, TT))
  cov.var.et <- array(0, dim = c(n, m, TT))
  msg <- NULL

  #### make a list of time-varying parameters
  time.varying <- list()
  for (elem in attr(MLEobj[["marss"]], "par.names")) {
    if (model.dims[[elem]][3] == 1) {
      time.varying[[elem]] <- FALSE
    } else {
      time.varying[[elem]] <- TRUE
    }
  }

  kf <- MARSSkfss(MLEobj)
  Ey <- MARSShatyt(MLEobj, only.kem=FALSE)
  Rt <- parmat(MLEobj, "R", t = 1)$R # returns matrix
  Ht <- parmat(MLEobj, "H", t = 1)$H
  Rt <- Ht %*% Rt %*% t(Ht)
  Zt <- parmat(MLEobj, "Z", t = 1)$Z

  if (method=="SS") {
    # model.et will be NA where no data E(y)-modeled(y) since y used here
    model.et <- y - fitted(MLEobj, type = "ytt1", output = "matrix") # model residuals

    for (t in 1:TT) {
      # model residuals
      if(time.varying$R) Rt <- parmat(MLEobj, "R", t = t)$R # returns matrix
      if(time.varying$H) Ht <- parmat(MLEobj, "H", t = t)$H
      if(time.varying$R || time.varying$H ) Rt <- Ht %*% Rt %*% t(Ht)
      if(time.varying$Z) Zt <- parmat(MLEobj, "Z", t = t)$Z
      model.var.et[, , t] <- Rt + tcrossprod(Zt %*% kf$Vtt1[, , t], Zt)
    }
    
    for(t in 1:TT){
      if(t < TT){
        state.et[,t] <- kf$Kt[, , t+1] %*% model.et[, t+1]
        cov.et <- tcrossprod(model.var.et[, , t+1], kf$Kt[, , t+1])
        tmpvar.state.et <- kf$Kt[, , t+1] %*% cov.et
      else {
        cov.et <- matrix(NA, n, m)
        tmpvar.state.et <- matrix(NA, m, m)
      }
      var.et[1:n, , t] <- cbind(model.var.et[, , t], cov.et)
      var.et[(n + 1):(n + m), , t] <- cbind(t(cov.et), tmpvar.state.et)

      if (normalize) {
        Rinv <- matrix(0, n, n + m)
        Rinv <- psolve(t(pchol(Rt)))
        et[, t] <- Rinv %*% et[, t]
        var.et[, , t] <- Rinv %*% var.et[, , t] %*% t(Rinv)
      }
    }
  }

  # prepare cholesky standardized residuals
  for (t in 1:TT) {
    tmpvar <- sub3D(var.et, t = t)
    resids <- et[, t, drop = FALSE]
    # don't include values for resids if there is no residual (no data)
    is.miss <- is.na(y[, t])
    resids[is.miss] <- 0

    tmpvar[abs(tmpvar) < sqrt(.Machine$double.eps)] <- 0

    # psolve and pchol deal with 0s on diagonal
    # wrapped in try to prevent crashing if inversion not possible
    tmpchol <- try(pchol(tmpvar), silent = TRUE)
    if (inherits(tmpchol, "try-error")) {
      st.et[, t] <- NA
      msg <- c(msg, paste("MARSSresiduals.tt1 warning: the variance of the residuals at t =", t, "is not invertible.  NAs returned for std.residuals at t =", t, ". See MARSSinfo(\"residvarinv\")\n"))
      next
    }
    tmpcholinv <- try(psolve(tmpchol), silent = TRUE)
    if (inherits(tmpcholinv, "try-error")) {
      st.et[, t] <- NA
      msg <- c(msg, paste("MARSSresiduals.tt1 warning: the variance of the residuals at t =", t, "is not invertible.  NAs returned for std.residuals at t =", t, "\n"))
      next
    }
    # inverse of diagonal of variance matrix for marginal standardization
    tmpvarinv <- try(psolve(makediag(takediag(tmpvar))), silent = TRUE)
    if (inherits(tmpvarinv, "try-error")) {
      mar.st.et[, t] <- NA
      msg <- c(msg, paste("MARSSresiduals.tt1 warning: the diagonal matrix of the variance of the residuals at t =", t, "is not invertible.  NAs returned for std.residuals at t =", t, "\n"))
      next
    }
    st.et[, t] <- tmpcholinv %*% resids
    st.et[is.miss, t] <- NA
    mar.st.et[, t] <- tmpvarinv %*% resids
    mar.st.et[is.miss, t] <- NA
  }
  
  # et is the expected value of the residuals conditioned on y(1)-the observed data
  E.obs.v <- Ey$ytt1 - fitted(MLEobj, type = "ytt1", output = "matrix")
  var.obs.v <- array(0, dim = c(n, n, TT))
  for( t in 1:TT) var.obs.v[,,t] <- Ey$Ott1[,,t] - tcrossprod(Ey$ytt1[,t])

  # add rownames
  Y.names <- attr(MLEobj$model, "Y.names")
  rownames(et) <- rownames(st.et) <- rownames(var.et) <- colnames(var.et) <- Y.names
  rownames(E.obs.v) <- rownames(var.obs.v) <- colnames(var.obs.v) <- Y.names
  
  # output any warnings
  if(!is.null(msg) && object[["control"]][["trace"]] >= 0 & !silent) cat("MARSSresiduals.tT reported warnings. See msg element of returned residuals object.\n")

  return(list(model.residuals = et, state.residuals = NULL, residuals = et, 
              std.residuals = st.et, mar.residuals = mar.st.et, 
              var.residuals = var.et, 
              E.obs.residuals = E.obs.v, var.obs.residuals = var.obs.v, msg = msg))
  
}
