\SweaveOpts{keep.source=TRUE, prefix.string=./figures/STS-, eps=FALSE, split=TRUE}
<<RUNFIRST, echo=FALSE, include.source=FALSE>>=
options(prompt=" ", continue=" ", width=60)
@
<<label=Cs01_required-libraries, echo=FALSE>>=
library(MARSS)
library(tidyr)
library(ggplot2)
library(forecast)
@
\chapter{Structural Time Series Models}
\label{chap:structts}
\chaptermark{STS Models}
%Add footnote with instructions for getting code
\blfootnote{Type \texttt{RShowDoc("Chapter\_Structural\_TS.R",package="MARSS")} at the R command line to open a file with all the code for the examples in this chapter.}


Structural time series models are linear Gaussian state-space models for time series which decompose the series into additive random walks for the level, trend and season. These models can be written as a multivariate state-space model. Traditionally, these models are fit to univariate data and R provides the \verb@StructTS()@ function in the stats package to fit the level, level plus trend, and level plus trend plus season versions of structural time series models.

Here it is shown how to fit structural time series models with \verb@MARSS()@ using the same initial conditions assumptions as used in the \verb@StructTS()@ function. With \verb@MARSS()@, you are not restricted to univariate time series and you have control over any parameter constraints (i.e. linear constraints) that you wish to impose. You will see how to do this after the univariate cases are shown.

\section{Univariate models}
\index{structural ts models!univariate}

\subsection{Level model}
\index{structural ts models!level}

The basic stochastic level model fit by \verb@stats::StructTS()@ is
\begin{equation}\label{eqn:struct.ts.y}
y_t = m_t+v_t \text{ where } v_t \sim \N(0,\sigma^2_\epsilon)  \\
\end{equation}
where $m$ is the level and is a random walk:

\begin{equation}\label{eqn:struct.ts.x}
m_t = m_{t-1}+ w_t \text{ where } w_t \sim \N(0,\sigma^2_\xi)
\end{equation}

The initial conditions assumption used in the \verb@StructTS()@ function is the following and this must be used in the \verb@MARSS()@ model in order to replicate the \verb@StructTS()@ output. The initial condition at $t=0$ for $m$ is stochastic with fixed mean equal to $y_1$ and variance equal to 10000 times the variance of the data, denoted $s^2$.

\begin{equation}\label{eqn:struct.ts.x0}
m_0 \sim \N(y_1, 10000 s^2)
\end{equation}

Here the model is fit to 20 time steps of tree ring data. \verb@fit1@ is the \verb@StructTS()@ output, 
\verb@fit2@ is fit with \verb@MARSS()@ with parameters fixed at the \verb@StructTS()@ estimated values, \verb@fit3@ is the model fit with \verb@MARSS()@ using BFGS, and \verb@fit4@ is the model fit with \verb@MARSS()@ using EM. \verb@fit3@ and \verb@fit4@ are slightly different than \verb@fit1@ because the optimization algorithm is a hill-climbing algorithm for all these fits and stops at slightly different points on the likelihood hill.

Another difference with \verb@StructTS()@ is that the reported fitted level (the $x$ state estimate) is the estimate of the state conditioned on the data up to $t$ not $T$. In the MARSS package, the state estimate (in the \verb@states@ element) is reported conditioned on all the data (up to $T$). To compare the outputs, we need to use \verb@MARSSkfss()@ to get \verb@xtt@ (the estimate of $x$ conditioned on data up to $t$). We set \verb@control=list(allow.degen=FALSE)@ when using the EM algorithm (the default) in order to compare results to the BFGS algorithm used in \verb@StructTS()@ which will not variances to go to zero (they may appear that way in the output but that is rounding).

<<label=Cs02_structTS-level, keep.source=TRUE, results=hide>>=
y <- window(treering, start = 0, end=20)
vy <- var(y, na.rm = TRUE)/100

fit1 <- StructTS(y, type = "level")
mod.list <- list(x0=matrix(y[1]), U="zero", tinitx=0, 
                 Q=matrix(fit1$coef[1]), R=matrix(fit1$coef[2]),
                 V0=matrix(1e+06 * vy))
fit2 <- MARSS(as.vector(y), model=mod.list)
fit2$kf <- MARSSkfss(fit2)
# Now estimate the parameters
mod.list <- list(x0=matrix(y[1]), U="zero", tinitx=0, V0=matrix(1e+06 * vy),
                 Q=matrix("s2xi"), R=matrix("s2eps"))
fit3 <- MARSS(as.vector(y), model=mod.list, method="BFGS")
fit3$kf <- MARSSkfss(fit3)
fit4 <- MARSS(as.vector(y), model=mod.list, control=list(allow.degen=FALSE))
fit4$kf <- MARSSkfss(fit4)
@

<<label=Cs03_level-output, keep.source=TRUE>>=
df <- data.frame(
  StructTS=fit1$fitted, fit2=fit2$kf$xtt[1,], 
  fit.bfgs=fit3$kf$xtt[1,], fit.em=fit4$kf$xtt[1,]
  )
head(df)
@

\begin{figure}[htp]
\begin{center}
<<label=Cs04_plot-structTS, echo=FALSE, keep.source=TRUE, fig=TRUE>>=
require(tidyr)
require(ggplot2)
df1 <- as.data.frame(fit1$fitted)
vars <- colnames(df1)
df2 <- as.data.frame(t(fit3$kf$xtt))
colnames(df2) <- vars
df3 <- as.data.frame(t(fit4$kf$xtt))
colnames(df3) <- vars
df1$model <- "StructTS"
df2$model <- "MARSS BFGS"
df3$model <- "MARSS EM"
df1$t <- as.vector(time(fit1$fitted))
df2$t <- df1$t
df3$t <- df1$t
df <- rbind(df1,df2,df3)
df <- df %>% pivot_longer(all_of(vars))
ggplot(df, aes(x=t, y=value)) + geom_line() + facet_wrap(~model) +
  ggtitle("Level estimate from model fit with StructTS and MARSS")
@
\end{center}
\caption{Comparison of the level estimates for the stochastic level model.}
\label{fig:STS.fig.level}
\end{figure}

\subsection{Level plus trend model}
\index{structural ts models!trend}

The basic stochastic level plus trend model fit by \verb@stats::StructTS()@ is
\begin{equation}\label{eqn:struct.ts.trend.y}
y_t = m_t+v_t \text{ where } v_t \sim \N(0,\sigma^2_\epsilon)  
\end{equation}
where $m$ and $n$ are the stochastic level and trend. $m_t=m_{t-1}+n_{t-1}+w_t$ and in matrix form this is
\begin{equation}\label{eqn:struct.ts.trend.x}
\begin{bmatrix}
m\\
n
\end{bmatrix}_t = \begin{bmatrix}
1&1\\
0&1
\end{bmatrix}\begin{bmatrix}
m\\
n
\end{bmatrix}_{t-1}+\ww_t \text{ where } \ww_t \sim \MVN\left(0,\begin{bmatrix}
\sigma^2_\xi&0\\
0&\sigma^2_\zeta
\end{bmatrix}\right) 
\end{equation}
The initial conditions assumption used in the \verb@StructTS()@ for this model is the following where $s^2$ is the variance in the data ($\var(y)$):

\begin{equation}\label{eqn:struct.ts.trend.x0}
\begin{bmatrix}
m\\
n
\end{bmatrix}_0 \sim \MVN\left(\begin{bmatrix}
y_1\\
0
\end{bmatrix},
\begin{bmatrix}
10000 s^2& 10000 s^2\\
10000 s^2& 10000 s^2
\end{bmatrix}\right) \\
\end{equation}

Because \verb@MARSS()@ does an inversion of \verb@V0@ as part of code to force positive definite matrices and deal with degenerate models with 0s on diagonals of $\QQ$ or $\RR$, the \verb@V0@  used in \verb@StructTS()@ needs to be made positive definite for \verb@MARSS()@. This is done by adding a small value (1e-10) to the diagonal as shown in the \verb@mod.list@ used for \verb@fit3@ and \verb@fit4@. This model will be illustrated with the \verb@UKgas@ data set since for the tree ring data the trend variance estimate is 0 and that will not illustrate a stochastic trend. The \verb@subset.ts()@ function in the forecast package is used to subset just the 2nd quarter data.

<<label=Cs05_structTS-leveltrend, keep.source=TRUE, results=hide>>=
y <- log10(forecast:::subset.ts(UKgas, quarter=2))
vy <- var(y, na.rm = TRUE)/100

fit1 <- StructTS(y, type = "trend")

B <- matrix(c(1,0,1,1),2,2)
Z <- matrix(c(1,0), 1, 2)
# fitx parameters at fit1 values
mod.list <- list(x0=matrix(c(y[1],0),2,1), U="zero", tinitx=0, 
                 Q=diag(fit1$coef[1:2]), R=matrix(fit1$coef[3]),
                 V0=matrix(1e+06 * vy,2,2), Z=Z, B=B)
fit2 <- MARSS(as.vector(y), model=mod.list, fit=FALSE, control=list(trace=-1))
fit2$par <- fit2$start
fit2$kf <- MARSSkfss(fit2)
# Now estimate the parameters with MARSS
mod.list <- list(x0=matrix(c(y[1],0),2,1), U="zero", tinitx=0,
                 Q=ldiag(c("s2xi","s2zeta")), R=matrix("s2eps"),
                 V0=matrix(1e+06 * vy,2,2)+diag(1e-10,2), Z=Z, B=B)
fit3 <- MARSS(as.vector(y), model=mod.list, method="BFGS")
fit3$kf <- MARSSkfss(fit3)
fit4 <- MARSS(as.vector(y), model=mod.list, control=list(allow.degen=FALSE))
fit4$kf <- MARSSkfss(fit4)
@

Trend estimate comparison for the first 5 time points. Figure \ref{fig:STS.fig.trend} shows the comparisons for the full level and trend estimates.  The EM algorithm would need a lower tolerance to get closer to the maximum likelihood parameter values.
<<label=Cs06_leveltrend-output>>=
data.frame(StructTS=fit1$fitted[,2], fit2=fit2$kf$xtt[2,], 
  fit.bfgs=fit3$kf$xtt[2,], fit.em=fit4$kf$xtt[2,])[1:5,]
@

\begin{figure}[htp]
\begin{center}
<<label=Cs07_plot-structTS-leveltrend, echo=FALSE, keep.source=TRUE, fig=TRUE>>=
require(tidyr)
require(ggplot2)
df1 <- as.data.frame(fit1$fitted)
vars <- colnames(df1)
df2 <- as.data.frame(t(fit3$kf$xtt))
colnames(df2) <- vars
df3 <- as.data.frame(t(fit4$kf$xtt))
colnames(df3) <- vars
df1$model <- "StructTS"
df2$model <- "MARSS BFGS"
df3$model <- "MARSS EM"
df1$t <- as.vector(time(fit1$fitted))
df2$t <- df1$t
df3$t <- df1$t
df <- rbind(df1,df2,df3)
df <- df %>% pivot_longer(all_of(vars))
ggplot(df, aes(x=t, y=value, color=model, linetype=model, shape=model)) + 
  geom_line() + geom_point() +
  facet_wrap(~name, scales = "free") +
  scale_linetype_manual("model",values=c(1,1,0)) +
  scale_shape_manual("model",values=c(NA,NA,16))
@
\end{center}
\caption{Comparison of the level and trend estimates for the stochastic level plus trend model.}
\label{fig:STS.fig.trend}
\end{figure}

\subsection{Seasonal or BSM model}
\index{structural ts models!seasonal}

The seasonal model fit by \verb@StructTS()@ is the level plus trend model with an additional seasonal component $s_t$. The $m_t$ model is the same as for the level plus trend model.
\begin{equation}\label{eqn:struct.bsm.y}
y_t = m_t+s_t+v_t \text{ where } v_t \sim \N(0,\sigma^2_\epsilon)
\end{equation}
where
\begin{equation}\label{eqn:struct.bsm.s}
s_t = -s_{t-1}-\dots-s_{t-f+1}+v_t \text{ where } v_t \sim \N(0,\sigma^2_w)
\end{equation}
$f$ is the frequency of the seasonality. So for quarterly data, $f=4$ and the $s_t$ model is
\begin{equation}\label{eqn:struct.bsm.s.qtr}
s_t = -s_{t-1}-s{t-2}-s_{t-3}+v_t \text{ where } v_t \sim \N(0,\sigma^2_w)
\end{equation}

Written in matrix form, the model for a quarterly seasonality is the following. $s$ is the seasonality term while $s_1$ and $s_2$ are just keeping track of $s_{t-1}$ and $s_{t-2}$.
\begin{equation}\label{eqn:struct.bsm.y.matrix}
y_t = \begin{bmatrix}1&0&1&0&0\end{bmatrix}\begin{bmatrix}
m\\
n \\
s\\
s_1\\
s_2
\end{bmatrix}_t + v_t
\end{equation}
and 
\begin{equation}\label{eqn:struct.bsm.x.matrix}
\begin{bmatrix}
m\\
n \\
s\\
s_2\\
s_3
\end{bmatrix}_t = \begin{bmatrix}
1&1&0&0&0\\
0&1&0&0&0\\
0&0&-1&-1&-1\\
0&0&1&0&0\\
0&0&0&1&0
\end{bmatrix}\begin{bmatrix}
m\\
n\\
s\\
s_2\\
s_3
\end{bmatrix}_{t-1}+\ww_t
\end{equation}
where
\begin{equation}\ww_t \sim \MVN\left(0,\begin{bmatrix}
\sigma^2_\xi&0&0&0&0\\
0&\sigma^2_\zeta&0&0&0\\
0&0&\sigma^2_w&0&0\\
0&0&0&0&0\\
0&0&0&0&0
\end{bmatrix}\right) \\
\end{equation}
The initial conditions assumption is the following where again $s^2$ is the variance in the data ($\var(y)$):
\begin{equation}\label{eqn:struct.bsm.x0}
\begin{bmatrix}
m\\
n\\
s\\
s_2\\
s_3
\end{bmatrix}_0 \sim \MVN\left(\begin{bmatrix}
y_1\\0\\0\\0\\0
\end{bmatrix},
\begin{bmatrix}
10^4 s^2& 10^4 s^2& 10^4 s^2& 10^4 s^2& 10^4 s^2\\
10^4 s^2& 10^4 s^2& 10^4 s^2& 10^4 s^2& 10^4 s^2\\
10^4 s^2& 10^4 s^2& 10^4 s^2& 10^4 s^2& 10^4 s^2\\
10^4 s^2& 10^4 s^2& 10^4 s^2& 10^4 s^2& 10^4 s^2\\
10^4 s^2& 10^4 s^2& 10^4 s^2& 10^4 s^2& 10^4 s^2
\end{bmatrix}\right)
\end{equation}

Let's see an example with the UKgas data set used in \verb@?StructTS()@.
<<label=Cs08_fit-structTS-bsm, keep.source=TRUE>>=
y <- log10(UKgas)
fit1 <- StructTS(y, type="BSM")
@
To make $\BB$, we write a little helper function. \verb@nf@ is the frequency.
<<label=Cs09_makeB>>=
makeB <- function(nf){
  B <- matrix(0, nf + 1L, nf + 1L)
  B[1L:2L, 1L:2L] <- c(1, 0, 1, 1)
  B[3L, ] <- c(0, 0, rep(-1, nf - 1L))
  if (nf >= 3L) {
    ind <- 3:nf
    B[cbind(ind + 1L, ind)] <- 1
  }
  return(B)
}
@
Now we can fit with \verb@MARSS()@. 
<<label=Cs10_fit-structTS-bsm-marss-bfgs, keep.source=TRUE, results=hide>>=
nf <- frequency(y)
vy <- var(y)/100
B <- makeB(nf)
Z <- matrix(c(1, 0, 1, rep(0, nf - 2L)),1,nf+1)

Q <- ldiag(list("s2xi","s2zeta","s2w",0,0))
R <- matrix("s2eps")
V0 <- matrix(1e+06 * vy,nf+1,nf+1)+diag(1e-10,nf+1)
mod.list <- list(x0=matrix(c(y[1],rep(0,nf)),ncol=1), U="zero", A="zero", tinitx=0, 
                 Q=Q, R=R, V0=V0, Z=Z, B=B)
fit3 <- MARSS(as.vector(y), model=mod.list, method="BFGS")
fit4 <- MARSS(as.vector(y), model=mod.list, control=list(allow.degen=FALSE))
fit4$kf <- MARSSkfss(fit4)
fit3$kf <- MARSSkfss(fit3)
@
Figure \ref{fig:STS.fig.bsm} shows the comparisons.

\begin{figure}[htp]
\begin{center}
<<label=Cs11_plot-structTS-bsm, echo=FALSE, keep.source=TRUE, fig=TRUE>>=
require(tidyr)
require(ggplot2)
df1 <- as.data.frame(fit1$fitted)
vars <- colnames(df1)
df2 <- as.data.frame(t(fit3$kf$xtt)[,1:3])
colnames(df2) <- vars
df3 <- as.data.frame(t(fit4$kf$xtt)[,1:3])
colnames(df3) <- vars
df1$model <- "StructTS"
df2$model <- "MARSS BFGS"
df3$model <- "MARSS EM"
df1$t <- as.vector(time(fit1$fitted))
df1$Qtr <- as.vector(cycle(fit1$fitted))
df2$t <- df1$t; df2$Qtr <- df1$Qtr
df3$t <- df1$t; df3$Qtr <- df1$Qtr
df <- rbind(df1,df2, df3)
df <- subset(df, Qtr==1) %>% pivot_longer(all_of(vars))
ggplot(df, aes(x=t, y=value, color=model, linetype=model, shape=model)) + 
  geom_line() + geom_point() +
  facet_wrap(~name, scales = "free") +
  scale_linetype_manual("model",values=c(1,1,0)) +
  scale_shape_manual("model",values=c(NA,NA,15))
@
\end{center}
\caption{Comparison of the level, trend and season estimates for the BSM model.}
\label{fig:STS.fig.bsm}
\end{figure}

\subsection{Forecasting}
\index{structural ts models!forecasting}

Forecasts can be made with the \verb@predict()@ function or the \verb@forecast()@ function in the forecast package. Here we will use the BSM model fits to illustrate forecasting the univariate models.


<<label=Cs12_pre-predict-fits, results=hide>>=
y <- log10(UKgas)
fit1 <- StructTS(y, type="BSM")

nf <- frequency(y)
vy <- var(y)/100
B <- makeB(nf) # defined in the BSM section above
Z <- matrix(c(1, 0, 1, rep(0, nf - 2L)),1,nf+1)
V0 <- matrix(1e+06 * vy,nf+1,nf+1)+diag(1e-10,nf+1)
mod.list <- list(x0=matrix(c(y[1],rep(0,nf)),ncol=1), U="zero", A="zero", tinitx=0, 
                 Q=diag(c(fit1$coef[1:3],0,0)), R=matrix(fit1$coef[4]), V0=V0, Z=Z, B=B)
fit2 <- MARSS(as.vector(y), model=mod.list)
@
\verb@fit1@ and \verb@fit2@ are exactly the same since \verb@fit2@ used the \verb@fit1@ estimated parameters.

\verb@stats::predict.StructTS()@ is only for forecasting and takes the fit and \verb@n.ahead@ as arguments. It returns a list with the forecasts in \verb@pred@ and a ts object and their standard errors in \verb@se@. 
<<label=Cs13_predict-level-1>>=
fr1 <- predict(fit1, n.ahead=5)
fr1
@

The \verb@MARSS::predict.marssMLE()@ does both predicting within the data (similar to other \verb@predict@ methods) and will forecast if \verb@n.ahead@ is passed in. It returns a list with the predictions and forecasts in \verb@pred@ as a data frame in long form (suitable for \verb@ggplot@ calls). The standard errors and intervals (confidence or prediction) are included in \verb@pred@. The standard error is not printed but is in the \verb@pred@ data frame.
<<label=Cs14_predict-level-2>>=
fr2 <- predict(fit2, n.ahead=5)
fr2
head(fr2$pred)
@

The estimates are the same. \verb@ft@ is the time steps associated with the forecast.
<<label=Cs15_predict-bsm-compare>>=
rbind(pred1=fr1$pred, pred2=fr2$pred$estimate[fr2$ft],
      se1=fr1$se, se2=fr2$pred$se[fr2$ft])
@

If we use the \verb@forecast::forecast.StructTS()@ function instead of \verb@predict()@, we get a forecast object that can be printed since the forecast package has a plot method for forecast objects.
The MARSS package has a plot method for marssPredict objects returned by \verb@predict()@ and \verb@forecast()@ functions used with marssMLE objects. The forecast function can be called with \verb@forecast::forecast()@ if you have the forecast package installed or \verb@forecast.marssMLE()@ if not.

The plots from the \verb@StructTS@ and \verb@marssMLE@ objects are similar though they have slightly different formats.
\begin{figure}[htp]
\begin{center}
<<label=Cs16_predict-bsm-compare, keep.source=TRUE, fig=TRUE, fig.width=6>>=
fr1 <- forecast::forecast(fit1, h=10)
fr2 <- forecast::forecast(fit2, h=10)
p1 <- ggplot2::autoplot(fr1, include=8)
p2 <- ggplot2::autoplot(fr2, include=8)
gridExtra::grid.arrange(p1, p2, nrow = 1)
@
\end{center}
\caption{Comparison of the forecast plots.}
\label{fig:STS.fig.bsm.forecasts}
\end{figure}

\subsection{Fitted values}
\index{structural ts models!fitted}

`fitted(x)` applied to a `StructTS` object will return the expected value of $X_t$ conditioned on the data up to time $t$. It is returned as a ts or mts object depending if there is one state ("level") or multiple ("trend" or "BSM"). There is a plot method for ts and mts objects.
<<label=Cs16_fitted-bsm-sts>>=
fitted1 <- fitted(fit1)
plot(fitted1)
@
In the MARSS package, this is returned with `broom::tidy(x, type="ytt")`. The `"tt"` means at $t$ conditioned on data 1 to $t$. It is returned as a data frame.

<<label=Cs16_fitted-bsm-compare>>=
fitted2 <- fitted(fit2, type="ytt")
ggplot(fitted2, aes(x=t, y=.fitted)) +
  geom_line() +
  facet_wrap(~.rownames)
@


<<reset, echo=FALSE>>=
options(prompt="> ", continue=" +", width=120)
@
